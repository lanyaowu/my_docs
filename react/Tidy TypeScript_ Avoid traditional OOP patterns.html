<!DOCTYPE html>
<!-- saved from url=(0058)https://fettblog.eu/tidy-typescript-avoid-traditional-oop/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Tidy TypeScript: Avoid traditional OOP patterns</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="theme-color" content="dodgerblue">
<meta name="description" content="Articles on web dev and software engineering: TypeScript, JavaScript, Rust, and more!">
<meta name="keywords" content="Web, Web Ops, DevOps, Performance, Front-End, JavaScript, CSS">

<link rel="stylesheet" href="./Tidy TypeScript_ Avoid traditional OOP patterns_files/main.css">
<link rel="stylesheet" href="./Tidy TypeScript_ Avoid traditional OOP patterns_files/css2">

<link rel="alternate" type="application/rss+xml" title="front-end technology talk » Updates" href="https://fettblog.eu/feed.xml">

<link rel="pingback" href="https://webmention.io/fettblog.eu/xmlrpc">
<link rel="webmention" href="https://webmention.io/fettblog.eu/webmention">
<link rel="apple-touch-icon" sizes="57x57" href="https://fettblog.eu/icon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="https://fettblog.eu/icon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="https://fettblog.eu/icon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="https://fettblog.eu/icon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="https://fettblog.eu/icon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="https://fettblog.eu/icon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="https://fettblog.eu/icon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="https://fettblog.eu/icon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://fettblog.eu/icon/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192" href="https://fettblog.eu/icon/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://fettblog.eu/icon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="https://fettblog.eu/icon/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://fettblog.eu/icon/favicon-16x16.png">
<link rel="manifest" href="https://fettblog.eu/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/icon/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<link rel="canonical" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/">
<link rel="preconnect" href="https://srv.carbonads.net/">
<link rel="preconnect" href="https://cdn4.buysellads.net/">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Tidy TypeScript: Avoid traditional OOP patterns">
<meta name="twitter:creator" content="@ddprrt">
<meta property="og:image" content="https://fettblog.eu/teasers/tidy-typescript-avoid-traditional-oop.png">
<meta property="og:image:secure_url" content="https://fettblog.eu/teasers/tidy-typescript-avoid-traditional-oop.png">
<meta name="twitter:image" content="https://fettblog.eu/teasers/tidy-typescript-avoid-traditional-oop.png">
<script id="_carbonads_projs" type="text/javascript" src="./Tidy TypeScript_ Avoid traditional OOP patterns_files/CE7DT2JM.json"></script></head>
<body>




<article class="wrapper h-entry">
<div class="bg">
<div class="preamble main-frame">

<h1>Tidy TypeScript: Avoid traditional OOP patterns</h1>




<div class="e-content">
<p>This is the third article in a <a href="https://fettblog.eu/archive/tidy-typescript/">series of articles</a> where I want to highlight ways on how to keep your TypeScript code neat and tidy. This series is heavily opinionated and you might find out things you don’t like. Don’t take it personally, it’s just an opinion.</p>
<p>This time we look at POOP, as in “Patterns of Object-Oriented Programming”. With traditional OOP I mostly mean class-based OOP, which I assume the vast majority of developers think of when talking OOP. If you come from Java or C#, you might see a lot of familiar constructs in TypeScript, which might end up as false friends in the end.</p>
<h2 id="avoid-static-classes">Avoid static classes <a class="direct-link" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/#avoid-static-classes">#</a></h2>
<p>One thing I see a lot from people who worked a lot with Java is their urge to wrap everything inside a class. In Java, you don’t have any other options as classes are the only way to structure code. In JavaScript (and thus: TypeScript) there are plenty of other possibilities that do what you want without any extra steps. One of those things is static classes or classes with static methods, a true Java pattern.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// Environment.ts</span><br><br><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Environment</span> <span class="token punctuation">{</span><br>  <span class="token keyword">private</span> <span class="token keyword">static</span> variableList<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br>  <span class="token keyword">static</span> <span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><br>  <span class="token keyword">static</span> <span class="token function">setVariable</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>  <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><br>  <span class="token keyword">static</span> <span class="token function">getValue</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">unknown</span>  <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// Usage in another file</span><br><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Environment <span class="token keyword">from</span> <span class="token string">"./Environment"</span><span class="token punctuation">;</span><br><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Environment<span class="token punctuation">.</span><span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>While this works and is even – sans type annotations – valid JavaScript, it’s way too much ceremony for something that can easily be just plain, boring functions:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// Environment.ts</span><br><span class="token keyword">const</span> variableList<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br><br><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><br><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setVariable</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>  <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><br><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getValue</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">unknown</span>  <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><br><br><span class="token comment">// Usage in another file</span><br><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Environment <span class="token keyword">from</span> <span class="token string">"./Environment"</span><span class="token punctuation">;</span><br><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Environment<span class="token punctuation">.</span><span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The interface for your users is exactly the same. You can access module scope variables just the way you would access static properties in a class, but you have them module-scoped automatically. You decide what to export and what to make visible, not some TypeScript field modifiers. Also, you don’t end up creating an <code>Environment</code> instance that doesn’t do anything.</p>
<p>Even the implementation becomes easier. Check out the class version of <code>variables()</code>:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Environment</span> <span class="token punctuation">{</span><br>  <span class="token keyword">private</span> <span class="token keyword">static</span> variableList<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br>  <span class="token keyword">static</span> <span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <br>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>variableList<span class="token punctuation">;</span><br>   <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>As opposed to the module version:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">const</span> variableList<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><br><br><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> variableList<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>No <code>this</code> means less to think about. As an added benefit, your bundlers have an easier time doing tree-shaking, so you end up only with the things you actually use:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// Only the variables function and variablesList </span><br><span class="token comment">// end up in the bundle</span><br><span class="token keyword">import</span> <span class="token punctuation">{</span> variables <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./Environment"</span><span class="token punctuation">;</span><br><br><span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">variables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>That’s why a proper module is always preferred to a class with static fields and methods. That’s just an added boilerplate with no extra benefit.</p>
<h2 id="avoid-namespaces">Avoid namespaces <a class="direct-link" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/#avoid-namespaces">#</a></h2>
<p>As with static classes, I see people with a Java or C# background clinging on to namespaces. Namespaces are a feature that TypeScript introduced to organize code long before ECMAScript modules were standardized. They allowed you to split things across files, merging them again with reference markers.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token comment">// file users/models.ts</span><br><span class="token keyword">namespace</span> Users <span class="token punctuation">{</span><br>  <span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><br>    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><br>    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token comment">// file users/controller.ts</span><br><br><span class="token comment">/// &lt;reference path="./models.ts" /&gt;</span><br><span class="token keyword">namespace</span> Users <span class="token punctuation">{</span><br>  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">updateUser</span><span class="token punctuation">(</span>p<span class="token operator">:</span> Person<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token comment">// do the rest</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Back then, TypeScript even had a bundling feature. It should still work to this day. But as said, this was before ECMAScript introduced modules. Now with modules, we have a way to organize and structure code that is compatible with the rest of the JavaScript ecosystem. So that’s a plus.</p>
<p>So what do we need namespaces for?</p>
<h3 id="extending-declarations">Extending declarations <a class="direct-link" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/#extending-declarations">#</a></h3>
<p>Namespaces are still valid if you want to extend definitions from a third party dependency, e.g. that lives inside node modules. Some of my articles use that heavily. For example if you want to extend the global <code>JSX</code> namespace and make sure <code>img</code> elements feature alt texts:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">namespace</span> <span class="token constant">JSX</span> <span class="token punctuation">{</span><br>  <span class="token keyword">interface</span> <span class="token class-name">IntrinsicElements</span> <span class="token punctuation">{</span><br>    <span class="token string">"img"</span><span class="token operator">:</span> HTMLAttributes <span class="token operator">&amp;</span> <span class="token punctuation">{</span><br>      alt<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span><br>      src<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span><br>      loading<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">'lazy'</span> <span class="token operator">|</span> <span class="token string">'eager'</span> <span class="token operator">|</span> <span class="token string">'auto'</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>Or if you want to write elaborate type definitions in ambient modules. But other than that? There is not much use for it anymore.</p>
<h3 id="needless-namespaces">Needless namespaces <a class="direct-link" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/#needless-namespaces">#</a></h3>
<p>Namespaces wrap your definitions into an Object. Writing something like this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">namespace</span> Users <span class="token punctuation">{</span><br>  <span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span><br>    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><br>    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createUser</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> User <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>emits something very elaborate:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">var</span> Users<span class="token punctuation">;</span><br><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>Users<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">function</span> <span class="token function">createUser</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token punctuation">{</span><br>            name<span class="token punctuation">,</span> age<br>        <span class="token punctuation">}</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    Users<span class="token punctuation">.</span>createUser <span class="token operator">=</span> createUser<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Users <span class="token operator">||</span> <span class="token punctuation">(</span>Users <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>This not only adds cruft but also keeps your bundlers from tree-shaking properly! Also using them becomes a bit wordier:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Users <span class="token keyword">from</span> <span class="token string">"./users"</span><span class="token punctuation">;</span><br><br>Users<span class="token punctuation">.</span>Users<span class="token punctuation">.</span><span class="token function">createUser</span><span class="token punctuation">(</span><span class="token string">"Stefan"</span><span class="token punctuation">,</span> <span class="token string">"39"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Dropping them makes things a lot easier. Stick to what JavaScript offers you. Not using namespaces outside of declaration files makes your code clear, simple, and tidy.</p>
<h2 id="avoid-abstract-classes">Avoid abstract classes <a class="direct-link" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/#avoid-abstract-classes">#</a></h2>
<p>Abstract classes are a way to structure a more complex class hierarchy where you pre-define some behavior, but leave the actual implementation of some features to classes that <em>extend</em> from your abstract class.</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Lifeform</span> <span class="token punctuation">{</span><br>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><br>  <span class="token keyword">abstract</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token keyword">extends</span> <span class="token class-name">Lifeform</span> <span class="token punctuation">{</span><br>  <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token string">"Walking, mostly..."</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>It’s for all sub-classes of <code>Lifeform</code> to implement <code>move</code>. This is a concept that exists in basically every class-based programming language. The problem is, JavaScript isn’t traditionally class-based. For example, an abstract class like below generates a valid JavaScript class, but is not allowed to be instantiated in TypeScript:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Lifeform</span> <span class="token punctuation">{</span><br>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">const</span> lifeform <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Lifeform</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token comment">//               ^ 💥 Cannot create an instance of an abstract class.(2511)</span></code></pre>
<p>This can lead to some unwanted situations if you’re writing regular JavaScript but rely on TypeScript to provide you the information in form of implicit documentation. E.g. if a function definition looks like this:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">moveLifeform</span><span class="token punctuation">(</span>lifeform<span class="token operator">:</span> Lifeform<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li>You or your users might read this as an invitation to pass a <code>Lifeform</code> object to <code>moveLifeform</code>. Internally, it calls <code>lifeform.move()</code>.</li>
<li><code>Lifeform</code> can be instantiated in JavaScript, as it is a valid class</li>
<li>The method <code>move</code> does not exist in <code>Lifeform</code>, thus breaking your application!</li>
</ul>
<p>This is due to a false sense of security. What you actually want is to put some pre-defined implementation in the prototype chain, and have a contract that definitely tells you what to expect:</p>
<pre class="language-typescript"><code class="language-typescript"><span class="token keyword">interface</span> <span class="token class-name">Lifeform</span> <span class="token punctuation">{</span><br>  <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">BasicLifeForm</span> <span class="token punctuation">{</span><br>  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span><br>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token keyword">extends</span> <span class="token class-name">BasicLifeForm</span> <span class="token keyword">implements</span> <span class="token class-name">Lifeform</span> <span class="token punctuation">{</span><br>  <span class="token function">move</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> <span class="token string">"Walking"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The moment you look up <code>Lifeform</code>, you can see the interface and everything it expects, but you hardly run into a situation where you instantiate the wrong class by accident.</p>
<h2 id="bottom-line">Bottom line <a class="direct-link" href="https://fettblog.eu/tidy-typescript-avoid-traditional-oop/#bottom-line">#</a></h2>
<p>TypeScript included bespoke mechanisms in the early years of the language, where there was a severe lack of structuring in JavaScript. Now that JavaScript reached a different language of maturity, it gives you enough means to structure your code. So it’s a really good idea to make use of what’s native and idiomatic: Modules, objects, and functions. Occasional classes.</p>

</div>
</div>
</article>



</body></html>