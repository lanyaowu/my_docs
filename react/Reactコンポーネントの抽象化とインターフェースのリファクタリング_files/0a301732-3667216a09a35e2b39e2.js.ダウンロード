(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9970],{2804:function(e,t,n){"use strict";n.d(t,{Wh:function(){return Mr},cn:function(){return kr},_8:function(){return Ur},FV:function(){return Lr},sJ:function(){return Nr},Zl:function(){return Dr}});var o=n(73935),r=n(67294);const a=new Map;function s(e){var t;return null!==(t=a.get(e))&&void 0!==t&&t}s.setPass=e=>{a.set(e,!0)},s.setFail=e=>{a.set(e,!1)};var i=s;var l=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};var u=function(e,t){if(null!=e)return e;throw new Error(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};var c=function(e,t,{error:n}={}){return null};var d={trace:function(e,t,n){return n()},wrap:function(e){return e}};var f={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var p=function(e,...t){0};function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class v{constructor(e){h(this,"key",void 0),this.key=e}}class g extends v{}class y extends v{}var S={AbstractRecoilValue:v,RecoilState:g,RecoilValueReadOnly:y,isRecoilValue:function(e){return e instanceof g||e instanceof y}},m=S.AbstractRecoilValue,w=S.RecoilState,b=S.RecoilValueReadOnly,A=S.isRecoilValue,T=Object.freeze({__proto__:null,AbstractRecoilValue:m,RecoilState:w,RecoilValueReadOnly:b,isRecoilValue:A});class _{}const R=new _;class E extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const V=new Map,M=new Map;class k extends Error{}var N={nodes:V,recoilValues:M,registerNode:function(e){if(V.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}V.set(e.key,e);const t=null==e.set?new T.RecoilValueReadOnly(e.key):new T.RecoilState(e.key);return M.set(e.key,t),t},getNode:function(e){const t=V.get(e);if(null==t)throw new k(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return V.get(e)},NodeMissingError:k,DefaultValue:_,DEFAULT_VALUE:R,RecoilValueNotReady:E};const{mapByDeletingFromMap:L,mapBySettingInMap:D,setByAddingToSet:U}=f,{getNode:B,getNodeMaybe:C}=N,I=Object.freeze(new Set);class F extends Error{}var x={getNodeLoadable:function(e,t,n){return B(n).get(e,t)},peekNodeLoadable:function(e,t,n){return B(n).peek(e,t)},setNodeValue:function(e,t,n,o){const r=B(n);if(null==r.set)throw new F(`Attempt to set read-only RecoilValue: ${n}`);return r.set(e,t,o)},cleanUpNode:function(e,t){B(t).cleanUp(e)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=C(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:L(e.atomValues,t),nonvalidatedAtoms:D(e.nonvalidatedAtoms,t,n),dirtyAtoms:U(e.dirtyAtoms,t)}},getDownstreamNodes:function(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:I;for(const t of e)o.has(t)||r.push(t)}return o}};var O=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};function P(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:O(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);u(r.get(e)).add(t)})),a){O(a,e).forEach((e=>{if(!r.has(e))return;const n=u(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var W={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),u(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:l(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:l(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=u(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&c("Tried to save dependencies to a discarded tree");const l=t.getGraph(n);if(P(e,l),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){P(e,t.getGraph(i.currentTree.version),l)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var u;const n=null===(u=i.nextTree)||void 0===u?void 0:u.version;if(void 0!==n){P(e,t.getGraph(n),l)}}}};const{getDownstreamNodes:$,getNodeLoadable:G,setNodeValue:z}=x,{saveDependencyMapToStore:j}=W,{getNodeMaybe:q}=N,{DefaultValue:K,RecoilValueNotReady:J}=N,{AbstractRecoilValue:H,RecoilState:Z,RecoilValueReadOnly:Q,isRecoilValue:X}=T;function Y(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=G(e,t,n)[1];if("loading"===r.state)throw new J(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),[s,i]=z(e,t,o.key,a);j(s,e,t.version);for(const[e,n]of i.entries())ee(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;ee(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=q(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else c(`Unknown action ${n.type}`)}function ee(e,t,n){"hasValue"===n.state&&n.contents instanceof K?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function te(e,t){e.replaceState((n=>{const o=function(e){return{...e,atomValues:new Map(e.atomValues),nonvalidatedAtoms:new Map(e.nonvalidatedAtoms),dirtyAtoms:new Set(e.dirtyAtoms)}}(n);for(const r of t)Y(e,o,r);return re(e,o),o}))}function ne(e,t,n,o){if(oe.length){const n=oe[oe.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else d.trace(o,n,(()=>te(e,[t])))}const oe=[];function re(e,t){const n=$(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=q(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function ae(e,t,n){ne(e,{type:"set",recoilValue:t,valueOrUpdater:n},t.key,"set Recoil value")}let se=0;var ie={RecoilValueReadOnly:Q,AbstractRecoilValue:H,RecoilState:Z,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&c("Tried to read from a discarded tree");const[s,l]=G(e,n,t);return i("recoil_async_selector_refactor")||j(s,e,n.version),l},setRecoilValue:ae,setRecoilValueLoadable:function(e,t,n){if(n instanceof K)return ae(e,t,n);ne(e,{type:"setLoadable",recoilValue:t,loadable:n},t.key,"set Recoil value")},markRecoilValueModified:function(e,t){ne(e,{type:"markModified",recoilValue:t},t.key,"mark RecoilValue modified")},setUnvalidatedRecoilValue:function(e,t,n){ne(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n},t.key,"set Recoil value")},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=se++,a=e.getState();return a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),u(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]),{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):c(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:X,applyAtomValueWrites:function(e,t){const n=l(e,(e=>e));return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof K?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return oe.push(e),()=>{for(const[t,n]of e)d.trace("Recoil batched updates","-",(()=>te(t,n)));oe.pop()!==e&&c("Incorrect order of batch popping")}},invalidateDownstreams_FOR_TESTING:re};const{unstable_batchedUpdates:le}=o;var ue={unstable_batchedUpdates:le};const{batchStart:ce}=ie,{unstable_batchedUpdates:de}=ue;let fe=de;var pe={getBatcher:()=>fe,setBatcher:e=>{fe=e},batchUpdates:e=>{fe((()=>{let t=()=>{};try{t=ce(),e()}finally{t()}}))}};var he={enqueueExecution:function(e,t){t()}};var ve=function*(e){for(const t of e)for(const e of t)yield e};var ge=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};var ye=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};const{graph:Se}=W;let me=0;const we=()=>me++;function be(){const e=we();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:new Map,nonvalidatedAtoms:new Map}}var Ae={makeEmptyTreeState:be,makeEmptyStoreState:function(){const e=be();return{currentTree:e,nextTree:null,previousTree:null,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,Se()),versionsUsedByComponent:new Map}},getNextTreeStateVersion:we};const{batchUpdates:Te}=pe,{getDownstreamNodes:_e,peekNodeLoadable:Re}=x,{graph:Ee}=W,{DEFAULT_VALUE:Ve,recoilValues:Me}=N,{getRecoilValueAsLoadable:ke,setRecoilValue:Ne}=ie,{getNextTreeStateVersion:Le,makeEmptyStoreState:De}=Ae;function Ue(e){return ye(e,(e=>u(Me.get(e))))}class Be{constructor(e){h(this,"_store",void 0),h(this,"getLoadable",(e=>ke(this._store,e))),h(this,"getPromise",(e=>this.getLoadable(e).toPromise())),h(this,"getNodes_UNSTABLE",(e=>{if(!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];return Ue(this._store.getState().currentTree.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?Me.values():!0===e.isInitialized?Ue(ve([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):ge(Me.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),h(this,"getDeps_UNSTABLE",(e=>{this.getLoadable(e);const t=this._store.getGraph(this._store.getState().currentTree.version).nodeDeps.get(e.key);return Ue(null!==t&&void 0!==t?t:[])})),h(this,"getSubscribers_UNSTABLE",(({key:e})=>{const t=this._store.getState().currentTree;return{nodes:Ue(ge(_e(this._store,t,new Set([e])),(t=>t!==e)))}})),h(this,"getInfo_UNSTABLE",(e=>{var t;const{key:n}=e,o=this._store.getState().currentTree,r=this._store.getGraph(o.version),a=this._store.getState().knownAtoms.has(n)?"atom":this._store.getState().knownSelectors.has(n)?"selector":void 0;return{loadable:Re(this._store,o,n),isActive:this._store.getState().knownAtoms.has(n)||this._store.getState().knownSelectors.has(n),isSet:"selector"!==a&&o.atomValues.has(n),isModified:o.dirtyAtoms.has(n),type:a,deps:Ue(null!==(t=r.nodeDeps.get(n))&&void 0!==t?t:[]),subscribers:this.getSubscribers_UNSTABLE(e)}})),h(this,"map",(e=>{const t=new Fe(this);return e(t),Ie(t.getStore_INTERNAL())})),h(this,"asyncMap",(async e=>{const t=new Fe(this);return await e(t),Ie(t.getStore_INTERNAL())})),this._store={getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return u(n.get(t));const o=Ee();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw new Error("Cannot subscribe to Snapshots")}}}getStore_INTERNAL(){return this._store}getID(){return this.getID_INTERNAL()}getID_INTERNAL(){return this._store.getState().currentTree.stateID}}function Ce(e,t,n=!1){const o=e.getState(),r=n?Le():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:new Map(t.atomValues),nonvalidatedAtoms:new Map(t.nonvalidatedAtoms)}:t,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),versionsUsedByComponent:new Map}}function Ie(e,t="current"){const n=e.getState(),o="current"===t?n.currentTree:u(n.previousTree);return new Be(Ce(e,o))}class Fe extends Be{constructor(e){super(Ce(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),h(this,"set",((e,t)=>{const n=this.getStore_INTERNAL();Te((()=>{Ne(n,e,t)}))})),h(this,"reset",(e=>Te((()=>Ne(this.getStore_INTERNAL(),e,Ve)))))}}var xe={Snapshot:Be,MutableSnapshot:Fe,freshSnapshot:function(e){const t=new Be(De());return null!=e?t.map(e):t},cloneSnapshot:Ie},Oe=xe.Snapshot,Pe=xe.MutableSnapshot,We=xe.freshSnapshot,$e=xe.cloneSnapshot,Ge=Object.freeze({__proto__:null,Snapshot:Oe,MutableSnapshot:Pe,freshSnapshot:We,cloneSnapshot:$e});var ze=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};const{useContext:je,useEffect:qe,useMemo:Ke,useRef:Je,useState:He}=r,{cleanUpNode:Ze,getDownstreamNodes:Qe,setNodeValue:Xe,setUnvalidatedAtomValue_DEPRECATED:Ye}=x,{graph:et,saveDependencyMapToStore:tt}=W,{cloneGraph:nt}=W,{applyAtomValueWrites:ot}=ie,{freshSnapshot:rt}=Ge,{getNextTreeStateVersion:at,makeEmptyStoreState:st}=Ae,{mapByDeletingMultipleFromMap:it}=f;function lt(){throw new Error("This component must be used inside a <RecoilRoot> component.")}const ut=Object.freeze({getState:lt,replaceState:lt,getGraph:lt,subscribeToTransactions:lt,addTransactionMetadata:lt});let ct=!1;function dt(e){if(ct)throw new Error("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");if(null===e.nextTree){const t=e.currentTree.version,n=at();e.nextTree={...e.currentTree,version:n,stateID:n,dirtyAtoms:new Set,transactionMetadata:{}},e.graphsByVersion.set(n,nt(u(e.graphsByVersion.get(t))))}}const ft=r.createContext({current:ut}),pt=()=>je(ft),ht=r.createContext(null);function vt(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,s]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of s)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);const r=Qe(e,n,o);for(const e of r){const o=t.nodeToComponentSubscriptions.get(e);if(o)for(const[e,[t,r]]of o)r(n)}let a="[available in dev build]";0,t.suspendedComponentResolvers.forEach((e=>d.trace("value became available, waking components",a,e)))}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function gt(e){const t=pt(),[n,o]=He([]);return e.setNotifyBatcherOfChange((()=>o({}))),qe((()=>{he.enqueueExecution("Batcher",(()=>{const e=t.current.getState(),{nextTree:n}=e;if(null===n)return;e.previousTree=e.currentTree,e.currentTree=n,e.nextTree=null,vt(t.current);const o=u(e.previousTree).version;e.graphsByVersion.delete(o),e.previousTree=null}))})),null}let yt=0;var St={useStoreRef:pt,useRecoilMutableSource:()=>je(ht),RecoilRoot:function({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){var a;let s;const i=Je(null),l=null!==(a=r.createMutableSource)&&void 0!==a?a:r.unstable_createMutableSource,c=null!==n&&void 0!==n?n:{getState:()=>s.current,replaceState:e=>{const t=d.current.getState();dt(t);const n=u(t.nextTree);let o;try{ct=!0,o=e(n)}finally{ct=!1}o!==n&&(t.nextTree=o,u(i.current)())},getGraph:e=>{const t=s.current.graphsByVersion;if(t.has(e))return u(t.get(e));const n=et();return t.set(e,n),n},subscribeToTransactions:(e,t)=>{if(null==t){const{transactionSubscriptions:t}=d.current.getState(),n=yt++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=d.current.getState();n.has(t)||n.set(t,new Map);const o=yt++;return u(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},addTransactionMetadata:e=>{dt(d.current.getState());for(const t of Object.keys(e))u(d.current.getState().nextTree).transactionMetadata[t]=e[t]}},d=Je(c);s=Je(null!=e?function(e,t){const n=st();return t({set:(t,o)=>{const r=n.currentTree,[a,s]=Xe(e,r,t.key,o),i=new Set(s.keys());tt(a,e,r.version);const l=it(r.nonvalidatedAtoms,i);n.currentTree={...r,dirtyAtoms:ze(r.dirtyAtoms,i),atomValues:ot(r.atomValues,s),nonvalidatedAtoms:l}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=Ye(n.currentTree,t,e)}))}}),n}(c,e):null!=t?function(e){return rt().map(e).getStore_INTERNAL().getState()}(t):st());const f=Ke((()=>l?l(s,(()=>s.current.currentTree.version)):null),[l,s]);return qe((()=>()=>{for(const e of d.current.getState().knownAtoms)Ze(d.current,e)}),[]),r.createElement(ft.Provider,{value:d},r.createElement(ht.Provider,{value:f},r.createElement(gt,{setNotifyBatcherOfChange:function(e){i.current=e}}),o))},sendEndOfBatchNotifications_FOR_TESTING:vt};var mt=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var wt=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var bt=function(e,t){if(!e)throw new Error(t)};var At,Tt=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const _t=null!==(At=r.useMutableSource)&&void 0!==At?At:r.unstable_useMutableSource;var Rt={mutableSourceExists:function(){return _t&&!("undefined"!==typeof window&&window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE)},useMutableSource:_t};const{useRef:Et}=r;var Vt=function(){return Et(),"<component name not available>"};const{useCallback:Mt,useEffect:kt,useMemo:Nt,useRef:Lt,useState:Dt}=r,{batchUpdates:Ut}=pe,{DEFAULT_VALUE:Bt,getNode:Ct,nodes:It}=N,{useRecoilMutableSource:Ft,useStoreRef:xt}=St,{isRecoilValue:Ot}=T,{AbstractRecoilValue:Pt,getRecoilValueAsLoadable:Wt,setRecoilValue:$t,setRecoilValueLoadable:Gt,setUnvalidatedRecoilValue:zt,subscribeToRecoilValue:jt}=ie,{Snapshot:qt,cloneSnapshot:Kt}=Ge,{setByAddingToSet:Jt}=f,{mutableSourceExists:Ht,useMutableSource:Zt}=Rt;function Qt(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:new Error(`Invalid value of loadable atom "${t.key}"`)}function Xt(e){return Ht()?function(e){const t=xt(),n=Mt((()=>Wt(t.current,e,t.current.getState().currentTree)),[t,e]),o=Vt(),r=Mt(((n,r)=>{const a=t.current,s=jt(a,e,(()=>{d.trace("RecoilValue subscription fired",e.key,(()=>{r()}))}),o);return()=>s.release(a)}),[e,t,o]);return Zt(Ft(),n,r)}(e):function(e){const t=xt(),[n,o]=Dt([]),r=Vt();return kt((()=>{const n=t.current,a=jt(n,e,(t=>{d.trace("RecoilValue subscription fired",e.key,(()=>{o([])}))}),r);return d.trace("initial update on subscribing",e.key,(()=>{n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push(d.wrap((()=>{o([])}))):o([])})),()=>a.release(n)}),[e,t]),Wt(t.current,e)}(e)}function Yt(e){const t=xt();return Qt(Xt(e),e,t)}function en(e){const t=xt();return Mt((n=>{$t(t.current,e,n)}),[t,e])}function tn(e){const t=xt();kt((()=>t.current.subscribeToTransactions(e).release),[e,t])}function nn(e){const t=e.atomValues,n=l(mt(t,((e,t)=>{const n=Ct(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return Tt(e.nonvalidatedAtoms,n)}function on(){const e=xt();return Mt((t=>{var n;const o=e.current.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Ut((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&Ct(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{Gt(e.current,new Pt(t),a.atomValues.has(t)?u(a.atomValues.get(t)):Bt)})),e.current.replaceState((e=>({...e,stateID:t.getID_INTERNAL()})))}))}),[e])}class rn{}const an=new rn;var sn={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useGotoRecoilSnapshot:on,useRecoilCallback:function(e,t){const n=xt(),o=on();return Mt(((...t)=>{const r=Kt(n.current);function a(e,t){$t(n.current,e,t)}function s(e){$t(n.current,e,Bt)}let i=an;return Ut((()=>{i=e({set:a,reset:s,snapshot:r,gotoSnapshot:o})(...t)})),i instanceof rn&&bt(!1),i}),null!=t?[...t,n]:void 0)},useRecoilInterface:function(){const e=xt(),[t,n]=Dt([]),o=Lt(new Set);o.current=new Set;const r=Lt(new Set),a=Lt(new Map),s=Mt((t=>{const n=a.current.get(t);n&&(n.release(e.current),a.current.delete(t))}),[e,a]),i=Vt();return kt((()=>{const t=e.current;function l(e,t){a.current.has(t)&&n([])}O(o.current,r.current).forEach((e=>{if(a.current.has(e))return void p(`Double subscription to RecoilValue "${e}"`);const n=jt(t,new Pt(e),(t=>{d.trace("RecoilValue subscription fired",e,(()=>{l(0,e)}))}),i);a.current.set(e,n),d.trace("initial update on subscribing",e,(()=>{t.getState().nextTree?t.getState().queuedComponentCallbacks_DEPRECATED.push(d.wrap((()=>{l(t.getState(),e)}))):l(t.getState(),e)}))})),O(r.current,o.current).forEach((e=>{s(e)})),r.current=o.current})),kt((()=>{const e=a.current;return()=>e.forEach(((e,t)=>s(t)))}),[s]),Nt((()=>{function t(t){return n=>{$t(e.current,t,n)}}function n(t){return o.current.has(t.key)||(o.current=Jt(o.current,t.key)),Wt(e.current,t)}function r(t){return Qt(n(t),t,e)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(e){return[r(e),t(e)]},getRecoilStateLoadable:function(e){return[n(e),t(e)]},getSetRecoilState:t,getResetRecoilState:function(t){return()=>$t(e.current,t,Bt)}}}),[o,e])},useRecoilSnapshot:function(){const e=xt(),[t,n]=Dt((()=>Kt(e.current)));return tn(Mt((e=>n(Kt(e))),[])),t},useRecoilState:function(e){return[Yt(e),en(e)]},useRecoilStateLoadable:function(e){return[Xt(e),en(e)]},useRecoilTransactionObserver:function(e){tn(Mt((t=>{e({snapshot:Kt(t,"current"),previousSnapshot:Kt(t,"previous")})}),[e]))},useRecoilValue:Yt,useRecoilValueLoadable:Xt,useResetRecoilState:function(e){const t=xt();return Mt((()=>{$t(t.current,e,Bt)}),[t,e])},useSetRecoilState:en,useSetUnvalidatedAtomValues:function(){const e=xt();return(t,n={})=>{Ut((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>zt(e.current,new Pt(n),t)))}))}},useTransactionObservation_DEPRECATED:function(e){tn(Mt((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(c("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=nn(o),a=nn(n),s=l(It,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=wt(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:tn};const{useMemo:ln}=r,{RecoilRoot:un,useStoreRef:cn}=St;var dn=function(){const e=cn().current;return ln((()=>function({children:t}){return r.createElement(un,{store_INTERNAL:e},t)}),[e])};var fn=function(e){return!!e&&"function"===typeof e.then};const pn={getValue(){if("loading"===this.state&&i("recoil_async_selector_refactor"))throw this.contents.then((({__value:e})=>e));if("hasValue"!==this.state)throw this.contents;return this.contents},toPromise(){return"hasValue"===this.state?Promise.resolve(this.contents):"hasError"===this.state?Promise.reject(this.contents):i("recoil_async_selector_refactor")?this.contents.then((({__value:e})=>e)):this.contents},valueMaybe(){return"hasValue"===this.state?this.contents:void 0},valueOrThrow(){if("hasValue"!==this.state)throw new Error(`Loadable expected value, but in "${this.state}" state`);return this.contents},errorMaybe(){return"hasError"===this.state?this.contents:void 0},errorOrThrow(){if("hasError"!==this.state)throw new Error(`Loadable expected error, but in "${this.state}" state`);return this.contents},promiseMaybe(){return"loading"===this.state?i("recoil_async_selector_refactor")?this.contents.then((({__value:e})=>e)):this.contents:void 0},promiseOrThrow(){if("loading"!==this.state)throw new Error(`Loadable expected promise, but in "${this.state}" state`);return i("recoil_async_selector_refactor")?this.contents.then((({__value:e})=>e)):this.contents},map(e){if("hasError"===this.state)return this;if("hasValue"===this.state)try{const t=e(this.contents);return fn(t)?gn(t):hn(t)}catch(t){return fn(t)?gn(t.next((()=>e(this.contents)))):vn(t)}if("loading"===this.state)return gn(this.contents.then(e).catch((t=>{if(fn(t))return t.then((()=>e(this.contents)));throw t})));throw new Error("Invalid Loadable state")}};function hn(e){return Object.freeze({state:"hasValue",contents:e,...pn})}function vn(e){return Object.freeze({state:"hasError",contents:e,...pn})}function gn(e){return Object.freeze({state:"loading",contents:e,...pn})}var yn={loadableWithValue:hn,loadableWithError:vn,loadableWithPromise:gn,loadableLoading:function(){return gn(new Promise((()=>{})))},loadableAll:function(e){return e.every((e=>"hasValue"===e.state))?hn(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?vn(u(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):gn(i("recoil_async_selector_refactor")?Promise.all(e.map((e=>e.contents))).then((e=>({__value:e}))):Promise.all(e.map((e=>e.contents))))}};Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,DataView;"undefined"!==typeof navigator&&navigator.product;var Sn=function(){let e,t;const n={get:n=>n===e?t:void 0,set:(o,r)=>(e=o,t=r,n)};return n};const mn=Symbol("ArrayKeyedMap"),wn=new Map;class bn{constructor(e){if(h(this,"_base",new Map),e instanceof bn)for(const[t,n]of e.entries())this.set(t,n);else if(e)for(const[t,n]of e)this.set(t,n);return this}get(e){const t=Array.isArray(e)?e:[e];let n=this._base;return t.forEach((e=>{var t;n=null!==(t=n.get(e))&&void 0!==t?t:wn})),void 0===n?void 0:n.get(mn)}set(e,t){const n=Array.isArray(e)?e:[e];let o=this._base,r=o;return n.forEach((e=>{r=o.get(e),r||(r=new Map,o.set(e,r)),o=r})),r.set(mn,t),this}delete(e){const t=Array.isArray(e)?e:[e];let n=this._base,o=n;return t.forEach((e=>{o=n.get(e),o||(o=new Map,n.set(e,o)),n=o})),o.delete(mn),this}entries(){const e=[];return function t(n,o){n.forEach(((n,r)=>{r===mn?e.push([o,n]):t(n,o.concat(r))}))}(this._base,[]),e.values()}toBuiltInMap(){return new Map(this.entries())}}var An=bn,Tn=Object.freeze({__proto__:null,ArrayKeyedMap:An});const{ArrayKeyedMap:_n}=Tn;var Rn=function(){return new _n};function En(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw new Error("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(fn(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>En(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return En(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:En(n,t)]=r;return En(o,t,n)}return e instanceof Set?En(Array.from(e).sort(((e,n)=>En(e,t).localeCompare(En(n,t)))),t,n):null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?En(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${En(n,t)}:${En(e[n],t,n)}`)).join(",")}}`}var Vn=function(e,t={allowFunctions:!1}){return En(e,t)};var Mn=function(){const e=new Map,t={get:t=>e.get(Vn(t)),set:(n,o)=>(e.set(Vn(n),o),t),map:e};return t};var kn=function(){let e;return{get:(t,n)=>{if(void 0!==e){for(const[r,a]of e.route){var o;if(t(r)!==a)return;null===n||void 0===n||null===(o=n.onCacheHit)||void 0===o||o.call(n,r)}return e.value}},set:(t,n)=>{e={route:t,value:n}},getRoot:()=>e}};var Nn={setInTreeCache:function e(t,n,o){if(null==t){if(0===n.length)return{type:"result",result:o};{const[t,...r]=n,[a,s]=t;return{type:"branch",nodeKey:a,branches:new Map([[s,e(null,r,o)]])}}}if(0===n.length){if("result"!==t.type&&bt(!1),t.result&&"loading"===t.result.state){return{type:"result",result:o}}t.result!==o&&bt(!1);return t}{const[r,...a]=n,[s,i]=r;return"branch"!==t.type&&bt(!1),t.nodeKey!==s&&bt(!1),t.branches.set(i,e(t.branches.get(i),a,o)),t}},getFromTreeCache:function e(t,n,o){var r;if(null==t)return;if("result"===t.type)return t.result;null===o||void 0===o||null===(r=o.onCacheHit)||void 0===r||r.call(o,t.nodeKey);const a=n(t.nodeKey);return e(t.branches.get(a),n,o)}};const{getFromTreeCache:Ln,setInTreeCache:Dn}=Nn;var Un=function(){let e;return{get:(t,n)=>Ln(e,t,n),set:(t,n)=>{e=Dn(e,t,n)},getRoot:()=>e}};const{getFromTreeCache:Bn,setInTreeCache:Cn}=Nn;var In=function(){let e;return{get:(t,n)=>Bn(e,(e=>Vn(t(e))),n),set:(t,n)=>{e=Cn(e,t.map((([e,t])=>[e,Vn(t)])),n)},getRoot:()=>e}};var Fn={startPerfBlock:function(e){return()=>null}};const{loadableWithError:xn,loadableWithPromise:On,loadableWithValue:Pn}=yn,{getNodeLoadable:Wn,peekNodeLoadable:$n,setNodeValue:Gn}=x,{saveDependencyMapToStore:zn}=W,{DEFAULT_VALUE:jn,RecoilValueNotReady:qn,registerNode:Kn}=N,{isRecoilValue:Jn}=T,{AbstractRecoilValue:Hn}=T,{setRecoilValueLoadable:Zn}=ie,{startPerfBlock:Qn}=Fn,Xn=Object.freeze(new Set),Yn=[],eo=new Map,to=(()=>{let e=0;return()=>e++})();var no=function(e){const{key:t,get:n,cacheImplementation_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0,a=o===Rn?Un():o===Mn?In():o===Sn?kn():Un(),s={depValuesDiscoveredSoFarDuringAsyncWork:null,latestLoadable:null,latestExecutionId:null,stateVersion:null};function i(e){e.getState().knownSelectors.add(t)}function l(e,t,n){if("loading"===t.state){let t=eo.get(n);null==t&&eo.set(n,t=new Set),t.add(e)}}function c(e,t,n){if(t.atomValues.has(n))return[new Map,u(t.atomValues.get(n))];const[,o]=Wn(e,t,n),r=e.getState().knownSelectors.has(n);return"loading"!==o.state&&r&&t.atomValues.set(n,o),[new Map,o]}function d(e,n,o,r,a){return n.then((n=>{const{__key:r,__value:s}=n;null!=r&&o.atomValues.set(r,Pn(s));const[i,l]=v(e,o,a);if(A(a)&&b(l,a),T(i),"loading"!==i.state&&(R(o,g(l),i),f(i,a)),"hasError"===i.state)throw i.contents;return"hasValue"===i.state?{__value:i.contents,__key:t}:i.contents})).catch((e=>{const t=xn(e);throw _(e),R(o,g(r),xn(e)),f(t,a),e}))}function f(e,n){A(n)&&(w(e),function(e,n){const o=eo.get(n);if(void 0!==o){for(const n of o)Zn(n,new Hn(t),e);eo.delete(n)}}(e,n))}function p(e,n,o,r){var a,s,i,l,u,c,d;(A(r)||n.version===(null===(a=e.getState())||void 0===a||null===(s=a.currentTree)||void 0===s?void 0:s.version)||n.version===(null===(i=e.getState())||void 0===i||null===(l=i.nextTree)||void 0===l?void 0:l.version))&&zn(new Map([[t,o]]),e,null!==(u=null===(c=e.getState())||void 0===c||null===(d=c.nextTree)||void 0===d?void 0:d.version)&&void 0!==u?u:e.getState().currentTree.version)}function h(e,t,n,o,r){n.add(o),p(e,t,n,r)}function v(e,o,r){const a=Qn(t);let s,i;const l=new Map,u=new Set;function v(t){const{key:n}=t;h(e,o,u,n,r);const[,a]=c(e,o,n);if(l.set(n,a),"hasValue"===a.state)return a.contents;throw a.contents}p(e,o,u,r);try{s=n({get:v}),s=Jn(s)?v(s):s,fn(s)?s=function(e,n,o,r,a){return n.then((e=>{const n=Pn(e);return _(e),R(o,g(r),n),f(n,a),{__value:e,__key:t}})).catch((t=>{if(A(a)&&b(r,a),fn(t))return d(e,t,o,r,a);const n=xn(t);throw _(t),R(o,g(r),n),f(n,a),t}))}(e,s,o,l,r).finally(a):a()}catch(y){s=y,fn(s)?s=d(e,s,o,l,r).finally(a):a()}return i=s instanceof Error?xn(s):fn(s)?On(s):Pn(s),T(i),[i,l]}function g(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}function y(e,t){const n=to(),[o,r]=v(e,t,n);return w(o,r,n,t),function(e,t,n){"loading"!==n.state&&R(e,t,n)}(t,g(r),o),l(e,o,n),o}function S(e,n){const o=function(e,n){var o;if(n.atomValues.has(t))return n.atomValues.get(t);const r=new Set(null!==(o=e.getGraph(n.version).nodeDeps.get(t))&&void 0!==o?o:Xn);return p(e,n,r,s.latestExecutionId),a.get((t=>{const[,o]=c(e,n,t);return o.contents}),{onCacheHit:o=>{o!==t&&h(e,n,r,o,s.latestExecutionId)}})}(e,n);return null!=o?(w(o),o):function(e,t){return null!=s.latestLoadable&&null!=s.latestExecutionId&&!function(e,t){var n,o;const r=null!==(n=s.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,a=Array((null!==(o=m.get(t.version))&&void 0!==o?o:new Map).entries()),i=m.has(t.version)&&a.length===r.size&&a.every((([e,t])=>r.get(e)===t));if(null==r||t.version===s.stateVersion||i)return!1;return m.set(t.version,new Map(r)),Array.from(r).some((([n,o])=>{const[,r]=c(e,t,n);return r.contents!==o.contents&&!("loading"===o.state&&"loading"!==r.state)}))}(e,t)}(e,n)?(l(e,u(s.latestLoadable),u(s.latestExecutionId)),u(s.latestLoadable)):y(e,n)}const m=new Map;function w(e,t,n,o){"loading"===e.state?(s.depValuesDiscoveredSoFarDuringAsyncWork=t,s.latestExecutionId=n,s.latestLoadable=e,s.stateVersion=null===o||void 0===o?void 0:o.version):(s.depValuesDiscoveredSoFarDuringAsyncWork=null,s.latestExecutionId=null,s.latestLoadable=null,s.stateVersion=null)}function b(e,t){A(t)&&(s.depValuesDiscoveredSoFarDuringAsyncWork=e)}function A(e){return e===s.latestExecutionId}function T(e){"loading"!==e.state&&_(e.contents)}function _(e){0}function R(e,n,o){e.atomValues.set(t,o),a.set(n,o)}function E(e){if(Yn.includes(t)){const e=`Recoil selector has circular dependencies: ${Yn.slice(Yn.indexOf(t)).join(" \u2192 ")}`;return xn(new Error(e))}Yn.push(t);try{return e()}finally{Yn.pop()}}function V(e,t){return a.get((n=>{const o=$n(e,t,n);return null===o||void 0===o?void 0:o.contents}))}function M(e,t){return i(e),[new Map,E((()=>S(e,t)))]}function k(e){e.atomValues.delete(t)}if(null!=r){return Kn({key:t,peek:V,get:M,set:function(e,t,n){i(e);const o=new Map,a=new Map;function s({key:n}){const[,o]=c(e,t,n);if("hasValue"===o.state)return o.contents;throw"loading"===o.state?new qn(n):o.contents}function l(n,o){const r="function"===typeof o?o(s(n)):o,[,i]=Gn(e,t,n.key,r);i.forEach(((e,t)=>a.set(t,e)))}return r({set:l,get:s,reset:function(e){l(e,jn)}},n),[o,a]},cleanUp:()=>{},invalidate:k,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}return Kn({key:t,peek:V,get:M,cleanUp:()=>{},invalidate:k,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})};const{loadableWithError:oo,loadableWithPromise:ro,loadableWithValue:ao}=yn,{getNodeLoadable:so,peekNodeLoadable:io,setNodeValue:lo}=x,{addToDependencyMap:uo,mergeDepsIntoDependencyMap:co,saveDependencyMapToStore:fo}=W,{DEFAULT_VALUE:po,RecoilValueNotReady:ho,registerNode:vo}=N,{AbstractRecoilValue:go}=T,{getRecoilValueAsLoadable:yo,isRecoilValue:So,setRecoilValueLoadable:mo}=ie,{startPerfBlock:wo}=Fn,bo=Object.freeze(new Set);function Ao(e){const t=[];for(const n of Array.from(e.keys()).sort()){const o=u(e.get(n));t.push(n),t.push(o.state),t.push(o.contents)}return t}const To=new Map;var _o=function(e){const{key:t,get:n,cacheImplementation_UNSTABLE:o}=e,r=null!=e.set?e.set:void 0;let a=null!==o&&void 0!==o?o:Rn();function s(e){e.getState().knownSelectors.add(t)}function i(e,t){if("loading"===t.state){let n=To.get(t);void 0===n&&To.set(t,n=new Set),n.add(e)}}function l(e,n){const o=To.get(e);if(void 0!==o){for(const e of o)mo(e,new go(t),n);To.delete(e)}}function u(e,o){var r;const s=new Map,u=null!==(r=e.getGraph(o.version).nodeDeps.get(t))&&void 0!==r?r:bo,c=Ao(new Map(Array.from(u).sort().map((t=>{const[n,r]=so(e,o,t);return co(n,s),fo(s,e,o.version),[t,r]})))),d=a.get(c);if(null!=d)return i(e,d),[s,d];const[f,p,h]=function(e,o){const r=wo(t),a=new Map,s=new Map;function i({key:n}){uo(t,n,s);const[r,i]=so(e,o,n);if(a.set(n,i),co(r,s),fo(s,e,o.version),"hasValue"===i.state)return i.contents;throw i.contents}try{const e=n({get:i}),t=So(e)?i(e):e;let o;return fn(t)?o=ro(t.finally(r)):(r(),o=ao(t)),[s,o,a]}catch(l){let n;return void 0!==l.then?n=ro(l.then((()=>{const n=yo(e,new go(t));if("hasError"===n.state)throw n.contents;return n.contents})).finally(r)):(r(),n=oo(l)),[s,n,a]}}(e,o);co(f,s),fo(s,e,o.version);const v=Ao(h);return i(e,p),function(e,n,o){"loading"!==o.state||o.contents.then((e=>{const t=ao(e);return a=a.set(n,t),l(o,t),e})).catch((e=>{if(fn(e))return e;const t=oo(e);return a=a.set(n,t),l(o,t),e})),a=a.set(n,o),"loading"!==o.state&&e.atomValues.set(t,o)}(o,v,p),[s,p]}function c(e,n){var o;const r=null!==(o=e.getGraph(n.version).nodeDeps.get(t))&&void 0!==o?o:bo,s=new Map(Array.from(r).sort().map((t=>[t,io(e,n,t)]))),i=new Map;for(const[t,a]of s.entries()){if(null==a)return;i.set(t,a)}const l=Ao(i);return a.get(l)}function d(e){e.atomValues.delete(t)}function f(e,n){s(e);const o=n.atomValues.get(t);return void 0!==o?[new Map,o]:u(e,n)}if(null!=r){return vo({key:t,peek:c,get:f,set:function(e,t,n){s(e);const o=new Map,a=new Map;function i({key:n}){const[r,a]=so(e,t,n);if(co(r,o),"hasValue"===a.state)return a.contents;throw"loading"===a.state?new ho(n):a.contents}function l(n,r){const s="function"===typeof r?r(i(n)):r,[l,u]=lo(e,t,n.key,s);co(l,o),u.forEach(((e,t)=>a.set(t,e)))}return r({set:l,get:i,reset:function(e){l(e,po)}},n),[o,a]},invalidate:d,cleanUp:()=>{},dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})}return vo({key:t,peek:c,get:f,invalidate:d,cleanUp:()=>{},dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1})};var Ro=i("recoil_async_selector_refactor")?no:_o;const{loadableWithError:Eo,loadableWithPromise:Vo,loadableWithValue:Mo}=yn,{DEFAULT_VALUE:ko,DefaultValue:No,registerNode:Lo}=N,{isRecoilValue:Do}=T,{markRecoilValueModified:Uo,setRecoilValue:Bo,setRecoilValueLoadable:Co}=ie;function Io(e){const{key:t,persistence_UNSTABLE:n}=e;let o,r=fn(e.default)?Vo(e.default.then((e=>{r=Mo(e);return{__key:t,__value:e}})).catch((e=>{throw r=Eo(e),e}))):Mo(e.default);const a=new Map;function s(n,o,s){if(n.getState().knownAtoms.has(t))return;if(n.getState().knownAtoms.add(t),"loading"===r.state){function l(){var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Uo(n,i)}r.contents.then(l).catch(l)}let u=ko,d=null;if(null!=e.effects_UNSTABLE){let o=!0;const l=e=>t=>{if(o){const e=u instanceof No||fn(u)?"hasValue"===r.state?r.contents:ko:u;u="function"===typeof t?t(e):t}else{if(fn(t))throw new Error("Setting atoms to async values is not implemented.");"function"!==typeof t&&(d={effect:e,value:t}),Bo(n,i,"function"===typeof t?n=>{const o=t(n);return d={effect:e,value:o},o}:t)}},p=e=>()=>l(e)(ko),h=e=>o=>{n.subscribeToTransactions((n=>{var a;let{currentTree:s,previousTree:i}=n.getState();i||(c("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=s);const l=s.atomValues.get(t);if(null==l||"hasValue"===l.state){var u,f,p;const n=null!=l?l.contents:ko,a=null!==(u=i.atomValues.get(t))&&void 0!==u?u:r,s="hasValue"===a.state?a.contents:ko;(null===(f=d)||void 0===f?void 0:f.effect)===e&&(null===(p=d)||void 0===p?void 0:p.value)===n||o(n,s)}(null===(a=d)||void 0===a?void 0:a.effect)===e&&(d=null)}),t)};for(const t of null!==(f=e.effects_UNSTABLE)&&void 0!==f?f:[]){var f;const e=t({node:i,trigger:s,setSelf:l(t),resetSelf:p(t),onSet:h(t)});null!=e&&a.set(n,e)}o=!1}u instanceof No||o.atomValues.set(t,fn(u)?Vo(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Bo(e,i,n),{__key:t,__value:n}})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Co(e,i,Eo(n)),n}));return o}(n,u)):Mo(u))}const i=Lo({key:t,peek:function(e,n){var a,s,i;return null!==(a=null!==(s=n.atomValues.get(t))&&void 0!==s?s:null===(i=o)||void 0===i?void 0:i[1])&&void 0!==a?a:r},get:function(e,a){if(s(e,a,"get"),a.atomValues.has(t))return[new Map,u(a.atomValues.get(t))];if(a.nonvalidatedAtoms.has(t)){if(null!=o)return o;if(null==n)return p(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),[new Map,r];const e=a.nonvalidatedAtoms.get(t),s=n.validator(e,ko),i=s instanceof No?r:Mo(s);return o=[new Map,i],o}return[new Map,r]},set:function(e,n,r){if(s(e,n,"set"),n.atomValues.has(t)){const e=u(n.atomValues.get(t));if("hasValue"===e.state&&r===e.contents)return[new Map,new Map]}else if(!n.nonvalidatedAtoms.has(t)&&r instanceof No)return[new Map,new Map];return o=void 0,[new Map,(new Map).set(t,Mo(r))]},cleanUp:function(e){var t;null===(t=a.get(e))||void 0===t||t(),a.delete(e)},invalidate:function(){o=void 0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0});return i}function Fo(e){const{default:t,...n}=e;return Do(t)?function(e){const t=Fo({...e,default:ko,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof No?t:u(e.persistence_UNSTABLE).validator(t,ko)},effects_UNSTABLE:e.effects_UNSTABLE});return Ro({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof No?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability})}({...n,default:t}):Io({...n,default:t})}var xo=Fo;let Oo=0;var Po=function(e){var t,n;let o=null!==(t=null===(n=e.cacheImplementationForParams_UNSTABLE)||void 0===n?void 0:n.call(e))&&void 0!==t?t:Mn();return t=>{var n,r;const a=o.get(t);if(null!=a)return a;const s=`${e.key}__selectorFamily/${null!==(n=Vn(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${Oo++}`,i=n=>e.get(t)(n),l=null===(r=e.cacheImplementation_UNSTABLE)||void 0===r?void 0:r.call(e);let u;if(null!=e.set){const n=e.set;u=Ro({key:s,get:i,set:(e,o)=>n(t)(e,o),cacheImplementation_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability})}else u=Ro({key:s,get:i,cacheImplementation_UNSTABLE:l,dangerouslyAllowMutability:e.dangerouslyAllowMutability});return o=o.set(t,u),u}};const{DEFAULT_VALUE:Wo,DefaultValue:$o}=N;var Go=function(e){let t=Mn();const n={key:e.key,default:Wo,persistence_UNSTABLE:e.persistence_UNSTABLE};let o;o=xo(n);const r=Po({key:`${e.key}__atomFamily/Default`,get:t=>({get:n})=>{const r=n("function"===typeof o?o(t):o);return r instanceof $o?"function"===typeof e.default?e.default(t):e.default:r},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return n=>{var o;const a=t.get(n);if(null!=a)return a;const s=xo({...e,key:`${e.key}__${null!==(o=Vn(n))&&void 0!==o?o:"void"}`,default:r(n),effects_UNSTABLE:"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(n):e.effects_UNSTABLE});return t=t.set(n,s),s}};const zo=Po({key:"__constant",get:e=>()=>e,cacheImplementationForParams_UNSTABLE:Rn});var jo=function(e){return zo(e)};const qo=Po({key:"__error",get:e=>()=>{throw new Error(e)},cacheImplementationForParams_UNSTABLE:Rn});var Ko=function(e){return qo(e)};var Jo=function(e){return e};const{loadableWithError:Ho,loadableWithPromise:Zo,loadableWithValue:Qo}=yn;function Xo(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function Yo(e){return null!=e&&!fn(e)}function er(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function tr(e){return null!=e&&"object"===typeof e&&e.hasOwnProperty("__value")?e.__value:e}function nr(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function or(e,t,n){return nr(e,n.map(((e,n)=>null==e?Qo(t[n]):fn(e)?Zo(e):Ho(e))))}var rr={waitForNone:Po({key:"__waitForNone",get:e=>({get:t})=>{const n=er(e),[o,r]=Xo(t,n);return or(e,o,r)}}),waitForAny:Po({key:"__waitForAny",get:e=>({get:t})=>{const n=er(e),[o,r]=Xo(t,n);if(r.some((e=>null==e)))return or(e,o,r);if(r.every(Yo))throw r.find(Yo);if(i("recoil_async_selector_refactor"))return new Promise(((t,n)=>{for(const[a,s]of r.entries())fn(s)&&s.then((n=>{o[a]=tr(n),r[a]=null,t(or(e,o,r))})).catch((e=>{r[a]=e,r.every(Yo)&&n(r[0])}))}));throw new Promise(((t,n)=>{for(const[a,s]of r.entries())fn(s)&&s.then((n=>{o[a]=n,r[a]=null,t(or(e,o,r))})).catch((e=>{r[a]=e,r.every(Yo)&&n(r[0])}))}))}}),waitForAll:Po({key:"__waitForAll",get:e=>({get:t})=>{const n=er(e),[o,r]=Xo(t,n);if(r.every((e=>null==e)))return nr(e,o);const a=r.find(Yo);if(null!=a)throw a;if(i("recoil_async_selector_refactor"))return Promise.all(r).then((t=>{return nr(e,(n=o,r=t,r.map(((e,t)=>void 0===e?n[t]:e))).map(tr));var n,r}));throw Promise.all(r).then((t=>nr(e,t)))}}),noWait:Po({key:"__noWait",get:e=>({get:t})=>{try{return Qo(t(e))}catch(n){return fn(n)?Zo(n):Ho(n)}}})};const{batchUpdates:ar,setBatcher:sr}=pe,{DefaultValue:ir}=N,{RecoilRoot:lr}=St,{isRecoilValue:ur}=T,{freshSnapshot:cr}=Ge,{useGotoRecoilSnapshot:dr,useRecoilCallback:fr,useRecoilSnapshot:pr,useRecoilState:hr,useRecoilStateLoadable:vr,useRecoilTransactionObserver:gr,useRecoilValue:yr,useRecoilValueLoadable:Sr,useResetRecoilState:mr,useSetRecoilState:wr,useSetUnvalidatedAtomValues:br,useTransactionObservation_DEPRECATED:Ar}=sn,{noWait:Tr,waitForAll:_r,waitForAny:Rr,waitForNone:Er}=rr;var Vr={DefaultValue:ir,RecoilRoot:lr,useRecoilBridgeAcrossReactRoots_UNSTABLE:dn,atom:xo,selector:Ro,atomFamily:Go,selectorFamily:Po,constSelector:jo,errorSelector:Ko,readOnlySelector:Jo,useRecoilValue:yr,useRecoilValueLoadable:Sr,useRecoilState:hr,useRecoilStateLoadable:vr,useSetRecoilState:wr,useResetRecoilState:mr,useRecoilCallback:fr,useGotoRecoilSnapshot:dr,useRecoilSnapshot:pr,useRecoilTransactionObserver_UNSTABLE:gr,useTransactionObservation_UNSTABLE:Ar,useSetUnvalidatedAtomValues_UNSTABLE:br,noWait:Tr,waitForNone:Er,waitForAny:Rr,waitForAll:_r,isRecoilValue:ur,batchUpdates:ar,setBatcher:sr,snapshot_UNSTABLE:cr},Mr=Vr.RecoilRoot,kr=Vr.atom,Nr=Vr.useRecoilValue,Lr=Vr.useRecoilState,Dr=Vr.useSetRecoilState,Ur=Vr.useRecoilCallback}}]);